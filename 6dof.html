<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6-DOF Robotic Arm Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            text-align: center;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 14px;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr 350px;
            gap: 20px;
            padding: 20px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e0e0e0;
        }

        .panel h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        .color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 2px solid #333;
            display: inline-block;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .value-display {
            min-width: 60px;
            text-align: right;
            font-weight: 600;
            color: #667eea;
            font-size: 13px;
        }

        canvas {
            border: 2px solid #667eea;
            border-radius: 8px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            display: block;
            cursor: move;
        }

        .canvas-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .info-box {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .info-label {
            color: #666;
            font-weight: 500;
        }

        .info-value {
            color: #333;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }

        button {
            width: 100%;;
            padding: 10px;
            background: #764ba2;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            transition: all 0.3s;
        }

        button:hover {
            background: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .view-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .view-btn {
            flex: 1;
            padding: 10px;
            background: #667eea;
            color: white;
            border: 2px solid #667eea;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .view-btn:hover {
            background: #764ba2;
            border-color: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .toggle-labels {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            padding: 8px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 12px;
        }

        .toggle-labels input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        #link-length-controls {
            display: none;
        }

        #link-length-controls.visible {
            display: block;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .explanation-section {
            max-width: 1400px;
            margin: 20px auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .explanation-section h2 {
            color: #667eea;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .explanation-section h3 {
            color: #764ba2;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        .explanation-section p {
            line-height: 1.8;
            margin-bottom: 15px;
            color: #555;
        }

        .explanation-section code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #d63384;
        }

        .explanation-section pre {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        .formula {
            background: #fff3cd;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>6-DOF Robotic Arm Simulator</h1>
            <div class="subtitle">Interactive Forward and Inverse Kinematics Visualization</div>
        </header>

        <div class="main-content">
            <!-- Left Panel: FK Controls -->
            <div class="panel">
                <h2>Forward Kinematics</h2>
                <h3 style="font-size: 14px; margin-top: 10px; color: #555; border-bottom: 1px solid #ddd; padding-bottom: 8px;">Joint Controls</h3>
                <div id="active-controls"></div>

                <h2 style="margin-top: 20px;">Quick Actions</h2>
                <button onclick="homePosition()">Home Position (All 90°)</button>
                <button onclick="printDHMatrix()">Print DH Parameters</button>
            </div>

            <!-- Center Panel: Visualization -->
            <div class="canvas-container">
                <canvas id="canvas" width="600" height="600"></canvas>
                <div class="view-controls">
                    <button class="view-btn" onclick="setView('top')">Top View</button>
                    <button class="view-btn" onclick="setView('side')">Side View</button>
                    <button class="view-btn" onclick="setView('iso')">Isometric</button>
                </div>
                <div class="toggle-labels">
                    <input type="checkbox" id="show-labels" checked onchange="draw()">
                    <label for="show-labels" style="cursor: pointer; margin: 0;">Show Labels</label>
                </div>
                <div class="toggle-labels">
                    <input type="checkbox" id="show-lengths" onchange="draw()">
                    <label for="show-lengths" style="cursor: pointer; margin: 0;">Show Link Lengths</label>
                </div>
                <div class="toggle-labels">
                    <input type="checkbox" id="edit-lengths" onchange="toggleLinkLengths()">
                    <label for="edit-lengths" style="cursor: pointer; margin: 0;">Edit Lengths</label>
                </div>
                <div id="link-length-controls"></div>
                <div class="info-box" style="margin-top: 10px;display:none" >
                    <div style="font-size: 12px; font-weight: 600; margin-bottom: 8px; color: #667eea;">End Effector Position</div>
                    <div class="info-row">
                        <span class="info-label">X:</span>
                        <span class="info-value" id="pos-x">0.00 mm</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Y:</span>
                        <span class="info-value" id="pos-y">0.00 mm</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Z:</span>
                        <span class="info-value" id="pos-z">0.00 mm</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Reach:</span>
                        <span class="info-value" id="pos-dist">0.00 mm</span>
                    </div>
                </div>
                <div style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 4px;">
                    <label style="font-size: 12px; font-weight: 600; margin-bottom: 5px; display: block;">Zoom: <span id="zoom-val">100%</span></label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button class="view-btn" onclick="adjustZoom(-0.1)" style="flex: 0;">-</button>
                        <input type="range" id="zoom-slider" min="0.5" max="2.0" value="1.0" step="0.1" oninput="updateZoom()" style="flex: 1;">
                        <button class="view-btn" onclick="adjustZoom(0.1)" style="flex: 0;">+</button>
                    </div>
                </div>
            </div>

            <!-- Right Panel: IK Controls -->
            <div class="panel">
                <h2>Inverse Kinematics</h2>
                <p style="font-size: 12px; color: #666; margin-bottom: 15px;">Set desired end effector position to compute joint angles</p>
                
                <div class="control-group">
                    <label>X Position (mm)</label>
                    <input type="number" id="ik-x" value="0" step="5" min="-1000" max="1000" oninput="solveIK()" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                </div>
                
                <div class="control-group">
                    <label>Y Position (mm)</label>
                    <input type="number" id="ik-y" value="588" step="5" min="-1000" max="1000" oninput="solveIK()" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                </div>
                
                <div class="control-group">
                    <label>Z Position (mm)</label>
                    <input type="number" id="ik-z" value="105" step="5" min="-1000" max="1000" oninput="solveIK()" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                </div>

                <div class="info-box" style="margin-top: 15px;">
                    <div class="info-row">
                        <span class="info-label">Status:</span>
                        <span class="info-value" id="ik-status" style="color: #28a745;">Valid</span>
                    </div>
                </div>

                <h3 style="font-size: 14px; margin-top: 20px; color: #555; border-bottom: 1px solid #ddd; padding-bottom: 8px;">Computed Joint Angles</h3>
                <div id="ik-joint-display" style="margin-top: 12px;"></div>
            </div>
        </div>
    </div>



    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let rotX = -78.0;
        let rotY = -9.0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let showLabels = true;
        let zoomLevel = 1.0;

        const arm = {
            joints: [90, 90, 90, 90, 90, 90],
            lengths: [105, 129, 110, 150, 80, 60],
            endEffector: { x: 0, y: 0, z: 0 }
        };

        const jointNames = ['Base (J1)', 'Shoulder (J2)', 'Elbow (J3)', 'Wrist Pitch (J4)', 'Wrist Roll (J5)', 'Gripper (J6)'];
        const colors = ['#8B4513', '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#9B59B6'];

        function deg2rad(deg) {
            return deg * Math.PI / 180;
        }

        function initControls() {
            const container = document.getElementById('active-controls');
            let html = '';
            
            for (let i = 0; i < 6; i++) {
                html += `
                    <div class="control-group">
                        <label>
                            <span class="color-indicator" style="background: ${colors[i]};"></span>
                            ${jointNames[i]}
                        </label>
                        <div class="control-row">
                            <input type="range" id="j${i+1}" min="0" max="180" value="${arm.joints[i]}" step="1" oninput="updateJoint(${i})">
                            <span class="value-display" id="j${i+1}-val">${arm.joints[i]}°</span>
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
            
            // Initialize link length controls
            const linkContainer = document.getElementById('link-length-controls');
            const linkNames = ['Base Height', 'Shoulder', 'Elbow', 'Wrist', 'Wrist 2', 'Gripper'];
            let linkHtml = '';
            
            for (let i = 0; i < 6; i++) {
                linkHtml += `
                    <div class="control-group">
                        <label style="font-size: 11px;">
                            L${i}: ${linkNames[i]}
                        </label>
                        <div class="control-row">
                            <input type="range" id="l${i}" min="10" max="300" value="${arm.lengths[i]}" step="1" oninput="updateLength(${i})">
                            <span class="value-display" id="l${i}-val" style="font-size: 11px;">${arm.lengths[i]}mm</span>
                        </div>
                    </div>
                `;
            }
            
            linkContainer.innerHTML = linkHtml;
        }

        function updateLength(index) {
            const slider = document.getElementById(`l${index}`);
            arm.lengths[index] = parseFloat(slider.value);
            document.getElementById(`l${index}-val`).textContent = arm.lengths[index] + 'mm';
            forwardKinematics();
            updateDisplay();
            draw();
        }

        function updateJoint(index) {
            const slider = document.getElementById(`j${index + 1}`);
            arm.joints[index] = parseFloat(slider.value);
            document.getElementById(`j${index + 1}-val`).textContent = arm.joints[index] + '°';
            forwardKinematics();
            updateDisplay();
            
            // Update IK textboxes with current end effector position
            document.getElementById('ik-x').value = arm.endEffector.x.toFixed(1);
            document.getElementById('ik-y').value = arm.endEffector.y.toFixed(1);
            document.getElementById('ik-z').value = arm.endEffector.z.toFixed(1);
            
            draw();
        }

        function toggleLinkLengths() {
            const checkbox = document.getElementById('edit-lengths');
            const container = document.getElementById('link-length-controls');
            if (checkbox.checked) {
                container.classList.add('visible');
            } else {
                container.classList.remove('visible');
            }
        }

        function forwardKinematics() {
            const [θ1, θ2, θ3, θ4, θ5, θ6] = arm.joints.map(deg2rad);
            const [l0, l1, l2, l3, l4, l5] = arm.lengths;

            // Adjust angles: 90° = straight/neutral position for pitch joints
            const θ2_adj = θ2 - Math.PI / 2;
            const θ3_adj = θ3 - Math.PI / 2;
            const θ4_adj = θ4 - Math.PI / 2;
            const θ5_adj = θ5 - Math.PI / 2;

            // Calculate horizontal reach in the XY plane
            const r = l1 * Math.cos(θ2_adj) + 
                      l2 * Math.cos(θ2_adj + θ3_adj) + 
                      l3 * Math.cos(θ2_adj + θ3_adj + θ4_adj) + 
                      l4 * Math.cos(θ2_adj + θ3_adj + θ4_adj + θ5_adj);
            
            // Rotate by base angle θ1
            // θ1 = 0° points along +Y axis
            // θ1 = 90° points along +X axis
            arm.endEffector.x = r * Math.sin(θ1);
            arm.endEffector.y = r * Math.cos(θ1);
            arm.endEffector.z = l0 + 
                                l1 * Math.sin(θ2_adj) + 
                                l2 * Math.sin(θ2_adj + θ3_adj) + 
                                l3 * Math.sin(θ2_adj + θ3_adj + θ4_adj) + 
                                l4 * Math.sin(θ2_adj + θ3_adj + θ4_adj + θ5_adj);

            // Debug output
            console.log(`FK: θ1=${arm.joints[0]}° r=${r.toFixed(2)}mm → X=${arm.endEffector.x.toFixed(2)}, Y=${arm.endEffector.y.toFixed(2)}, Z=${arm.endEffector.z.toFixed(2)}`);

            return arm.endEffector;
        }

        function updateDisplay() {
            document.getElementById('pos-x').textContent = arm.endEffector.x.toFixed(2) + ' mm';
            document.getElementById('pos-y').textContent = arm.endEffector.y.toFixed(2) + ' mm';
            document.getElementById('pos-z').textContent = arm.endEffector.z.toFixed(2) + ' mm';
            
            const dist = Math.sqrt(
                arm.endEffector.x ** 2 + 
                arm.endEffector.y ** 2 + 
                arm.endEffector.z ** 2
            );
            document.getElementById('pos-dist').textContent = dist.toFixed(2) + ' mm';
        }


        function homePosition() {
            // Home position: all joints at 90° (horizontal, pointing along +Y)
            arm.joints = [90, 90, 90, 90, 90, 90];
            initControls();
            forwardKinematics();
            updateDisplay();
            draw();
        }

        // Inverse Kinematics Solver
        function solveIK() {
            const targetX = parseFloat(document.getElementById('ik-x').value);
            const targetY = parseFloat(document.getElementById('ik-y').value);
            const targetZ = parseFloat(document.getElementById('ik-z').value);
            
            const [l0, l1, l2, l3, l4, l5] = arm.lengths;
            
            // Compute J1 from X, Y using atan2
            const j1_rad = Math.atan2(targetX, targetY);
            const j1_deg = j1_rad * 180 / Math.PI;
            
            // Adjust to 0-180 range if needed
            let j1 = j1_deg;
            if (j1 < 0) j1 += 360;
            if (j1 > 180) j1 -= 360;
            
            // Calculate the horizontal reach in the plane
            const horizontalReach = Math.sqrt(targetX * targetX + targetY * targetY);
            
            // Adjust Z for base height
            const relativeZ = targetZ - l0;
            
            // Use 2-link IK for J2-J5 to reach (horizontalReach, relativeZ)
            // We need to solve: horizontalReach = l1*cos(a1) + l2*cos(a1+a2) + l3*cos(a1+a2+a3) + l4*cos(a1+a2+a3+a4)
            //                   relativeZ = l1*sin(a1) + l2*sin(a1+a2) + l3*sin(a1+a2+a3) + l4*sin(a1+a2+a3+a4)
            // where a1,a2,a3,a4 are the adjusted angles (input - 90)
            
            // Use numerical solver - simple gradient descent
            const result = solveChainIK(horizontalReach, relativeZ, l1, l2, l3, l4);
            
            if (result.valid) {
                // Convert to joint angles (add 90° offset)
                arm.joints[0] = j1;
                arm.joints[1] = result.j2;
                arm.joints[2] = result.j3;
                arm.joints[3] = result.j4;
                arm.joints[4] = result.j5;
                arm.joints[5] = 90; // J6 stays at 90
                
                // Update display
                updateIKDisplay(result);
                document.getElementById('ik-status').textContent = 'Valid';
                document.getElementById('ik-status').style.color = '#28a745';
                
                // Update FK sliders and visualization
                for (let i = 0; i < 6; i++) {
                    const slider = document.getElementById(`j${i+1}`);
                    if (slider) {
                        slider.value = arm.joints[i];
                        document.getElementById(`j${i+1}-val`).textContent = arm.joints[i].toFixed(1) + '°';
                    }
                }
                
                forwardKinematics();
                updateDisplay();
                draw();
            } else {
                document.getElementById('ik-status').textContent = 'Out of Reach';
                document.getElementById('ik-status').style.color = '#dc3545';
                updateIKDisplay(null);
            }
        }

        // Numerical solver for the 4-link chain (J2-J5)
        function solveChainIK(targetX, targetZ, l1, l2, l3, l4) {
            const maxReach = l1 + l2 + l3 + l4;
            const minReach = Math.abs(l1 - l2 - l3 - l4);
            const targetReach = Math.sqrt(targetX * targetX + targetZ * targetZ);
            
            // Check if target is reachable
            if (targetReach > maxReach || targetReach < minReach) {
                return { valid: false };
            }
            
            // Initial guess using simple approach
            // Try to distribute reach evenly
            let j2 = 90, j3 = 90, j4 = 90, j5 = 90;
            
            // Use simple analytical solution for 2-link approximation first
            // Then refine with numerical method
            const twoLinkReach = l1 + l2 + l3 + l4;
            const angle = Math.atan2(targetZ, targetX);
            
            // Initial angles
            j2 = 90 + angle * 180 / Math.PI * 0.5;
            j3 = 90;
            j4 = 90;
            j5 = 90;
            
            // Refine using numerical method (simple iteration)
            for (let iter = 0; iter < 50; iter++) {
                const fk = forwardChainKinematics(j2, j3, j4, j5, l1, l2, l3, l4);
                const errorX = targetX - fk.x;
                const errorZ = targetZ - fk.z;
                const error = Math.sqrt(errorX * errorX + errorZ * errorZ);
                
                if (error < 1) break; // Converged
                
                // Adjust angles to reduce error
                const step = 0.5;
                j2 += errorZ * 0.01;
                j3 += errorX * 0.001;
                j4 += errorZ * 0.001;
                
                // Clamp angles
                j2 = Math.max(0, Math.min(180, j2));
                j3 = Math.max(0, Math.min(180, j3));
                j4 = Math.max(0, Math.min(180, j4));
                j5 = Math.max(0, Math.min(180, j5));
            }
            
            return {
                valid: true,
                j2: j2,
                j3: j3,
                j4: j4,
                j5: j5,
                error: 0
            };
        }

        // Forward kinematics for the 4-link chain
        function forwardChainKinematics(j2, j3, j4, j5, l1, l2, l3, l4) {
            const θ2 = (j2 - 90) * Math.PI / 180;
            const θ3 = (j3 - 90) * Math.PI / 180;
            const θ4 = (j4 - 90) * Math.PI / 180;
            const θ5 = (j5 - 90) * Math.PI / 180;
            
            const x = l1 * Math.cos(θ2) + l2 * Math.cos(θ2 + θ3) + l3 * Math.cos(θ2 + θ3 + θ4) + l4 * Math.cos(θ2 + θ3 + θ4 + θ5);
            const z = l1 * Math.sin(θ2) + l2 * Math.sin(θ2 + θ3) + l3 * Math.sin(θ2 + θ3 + θ4) + l4 * Math.sin(θ2 + θ3 + θ4 + θ5);
            
            return { x, z };
        }

        // Update IK display panel
        function updateIKDisplay(result) {
            const display = document.getElementById('ik-joint-display');
            if (!result) {
                display.innerHTML = '<p style="color: #dc3545; font-size: 12px;">Unable to compute IK solution</p>';
                return;
            }
            
            const angles = [arm.joints[0], result.j2, result.j3, result.j4, result.j5, 90];
            const names = ['J1 (Base)', 'J2 (Shoulder)', 'J3 (Elbow)', 'J4 (Wrist Pitch)', 'J5 (Wrist Roll)', 'J6 (Gripper)'];
            const colorList = ['#8B4513', '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#9B59B6'];
            
            let html = '';
            for (let i = 0; i < 6; i++) {
                html += `
                    <div style="padding: 8px; background: white; border-left: 4px solid ${colorList[i]}; margin-bottom: 8px; border-radius: 4px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; font-size: 12px;">
                            <span style="font-weight: 600; color: #333;">${names[i]}:</span>
                            <span style="font-weight: 700; color: ${colorList[i]}; font-size: 14px;">${angles[i].toFixed(1)}°</span>
                        </div>
                    </div>
                `;
            }
            display.innerHTML = html;
        }

        function printDHMatrix() {
            const [l0, l1, l2, l3, l4, l5] = arm.lengths;
            const [θ1, θ2, θ3, θ4, θ5, θ6] = arm.joints;
            
            // Create modal overlay
            const modalHTML = `
                <div id="dh-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;">
                    <div style="background: white; border-radius: 12px; padding: 30px; max-width: 800px; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h2 style="margin: 0; color: #667eea;">DH Parameters (Python Format)</h2>
                            <button onclick="document.getElementById('dh-modal').remove()" style="background: #f0f0f0; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 16px;">×</button>
                        </div>
                        <pre style="background: #f5f5f5; padding: 15px; border-radius: 6px; overflow-x: auto; border-left: 4px solid #667eea; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.5; color: #333;">import numpy as np

# Current Joint Angles (degrees)
J1 = ${θ1.toFixed(2)}
J2 = ${θ2.toFixed(2)}
J3 = ${θ3.toFixed(2)}
J4 = ${θ4.toFixed(2)}
J5 = ${θ5.toFixed(2)}
J6 = ${θ6.toFixed(2)}

# Link Lengths (mm)
L0 = ${l0.toFixed(2)}
L1 = ${l1.toFixed(2)}
L2 = ${l2.toFixed(2)}
L3 = ${l3.toFixed(2)}
L4 = ${l4.toFixed(2)}
L5 = ${l5.toFixed(2)}

# Denavit-Hartenberg Parameters
dh_params = [
    # Joint 1: theta1_DH = theta1_cmd - 90°
    {'d': ${l0.toFixed(2)}, 'a': 0, 'alpha': 90, 'theta_offset': -90},
    
    # Joint 2: theta2_DH = theta2_cmd - 90°
    {'d': 0, 'a': ${l1.toFixed(2)}, 'alpha': 0, 'theta_offset': -90},
    
    # Joint 3: theta3_DH = theta3_cmd - 90°
    {'d': 0, 'a': ${l2.toFixed(2)}, 'alpha': 0, 'theta_offset': -90},
    
    # Joint 4: theta4_DH = theta4_cmd - 90°
    {'d': 0, 'a': ${l3.toFixed(2)}, 'alpha': 0, 'theta_offset': -90},
    
    # Joint 5: theta5_DH = theta5_cmd - 90°
    {'d': 0, 'a': ${l4.toFixed(2)}, 'alpha': 0, 'theta_offset': -90},
    
    # Joint 6: theta6_DH = theta6_cmd - 90°
    {'d': 0, 'a': ${l5.toFixed(2)}, 'alpha': 0, 'theta_offset': -90},
]

# End Effector Position
X = ${arm.endEffector.x.toFixed(2)}  # mm
Y = ${arm.endEffector.y.toFixed(2)}  # mm
Z = ${arm.endEffector.z.toFixed(2)}  # mm</pre>
                        <div style="margin-top: 15px; font-size: 12px; color: #666; background: #f9f9f9; padding: 12px; border-radius: 6px;">
                            <strong>Parameter Legend:</strong><br>
                            • <strong>theta</strong>: Joint angle (degrees)<br>
                            • <strong>d</strong>: Link offset along Z-axis (mm)<br>
                            • <strong>a</strong>: Link length along X-axis (mm)<br>
                            • <strong>alpha</strong>: Link twist around X-axis (degrees)
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        function project3D(x, y, z) {
            const maxReach = 600;
            const padding = 50;
            const availableSize = Math.min(canvas.width, canvas.height) - padding * 2;
            const scale = (availableSize / maxReach) * zoomLevel;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            const radX = deg2rad(rotX);
            const radY = deg2rad(rotY);
            
            const cosX = Math.cos(radX);
            const sinX = Math.sin(radX);
            const cosY = Math.cos(radY);
            const sinY = Math.sin(radY);
            
            let y1 = y * cosX - z * sinX;
            let z1 = y * sinX + z * cosX;
            
            let x2 = x * cosY + z1 * sinY;
            let z2 = -x * sinY + z1 * cosY;
            
            return {
                x: centerX + x2 * scale,
                y: centerY - y1 * scale
            };
        }

        function drawLine3D(x1, y1, z1, x2, y2, z2, color, width) {
            const p1 = project3D(x1, y1, z1);
            const p2 = project3D(x2, y2, z2);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        function drawJoint(x, y, z, radius, color) {
            const p = project3D(x, y, z);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function drawLabel(x, y, z, text, color = '#000') {
            if (!showLabels) return;
            
            const p = project3D(x, y, z);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.92)';
            ctx.strokeStyle = color;
            ctx.lineWidth = 2.5;
            
            const padding = 8;
            ctx.font = 'bold 14px Arial';
            const textWidth = ctx.measureText(text).width;
            const boxWidth = textWidth + padding * 2;
            const boxHeight = 24;
            
            ctx.fillRect(p.x - boxWidth/2, p.y - boxHeight/2 - 25, boxWidth, boxHeight);
            ctx.strokeRect(p.x - boxWidth/2, p.y - boxHeight/2 - 25, boxWidth, boxHeight);
            
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, p.x, p.y - 13);
        }

        function drawLinkLength(x1, y1, z1, x2, y2, z2, length, color = '#000') {
            const showLengths = document.getElementById('show-lengths').checked;
            if (!showLengths) return;
            
            // Calculate midpoint
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const midZ = (z1 + z2) / 2;
            
            const p = project3D(midX, midY, midZ);
            
            // Draw length label
            const text = `${length.toFixed(0)}mm`;
            ctx.font = 'bold 12px Arial';
            const textWidth = ctx.measureText(text).width;
            const padding = 6;
            const boxWidth = textWidth + padding * 2;
            const boxHeight = 20;
            
            // Background
            ctx.fillStyle = 'rgba(255, 255, 200, 0.95)';
            ctx.fillRect(p.x - boxWidth/2, p.y - boxHeight/2, boxWidth, boxHeight);
            
            // Border
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(p.x - boxWidth/2, p.y - boxHeight/2, boxWidth, boxHeight);
            
            // Text
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, p.x, p.y);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            showLabels = document.getElementById('show-labels').checked;
            
            drawGrid();
            
            const [θ1, θ2, θ3, θ4, θ5, θ6] = arm.joints.map(deg2rad);
            const [l0, l1, l2, l3, l4, l5] = arm.lengths;
            
            const θ2_adj = θ2 - Math.PI / 2;
            const θ3_adj = θ3 - Math.PI / 2;
            const θ4_adj = θ4 - Math.PI / 2;
            const θ5_adj = θ5 - Math.PI / 2;
            
            const cosθ1 = Math.cos(θ1);
            const sinθ1 = Math.sin(θ1);
            
            // Calculate all joint positions
            const positions = [
                { x: 0, y: 0, z: 0 },  // Ground
                { x: 0, y: 0, z: l0 }  // J1 (top of base - always fixed)
            ];
            
            // J2 position
            const r1 = l1 * Math.cos(θ2_adj);
            positions.push({
                x: r1 * cosθ1,
                y: r1 * sinθ1,
                z: l0 + l1 * Math.sin(θ2_adj)
            });
            
            console.log(`J2 position: θ1=${(θ1*180/Math.PI).toFixed(1)}°, r1=${r1.toFixed(2)}, x=${(r1 * cosθ1).toFixed(2)}, y=${(r1 * sinθ1).toFixed(2)}`);
            
            // J3 position
            const r2 = l1 * Math.cos(θ2_adj) + l2 * Math.cos(θ2_adj + θ3_adj);
            positions.push({
                x: r2 * cosθ1,
                y: r2 * sinθ1,
                z: l0 + l1 * Math.sin(θ2_adj) + l2 * Math.sin(θ2_adj + θ3_adj)
            });
            
            // J4 position
            const r3 = l1 * Math.cos(θ2_adj) + l2 * Math.cos(θ2_adj + θ3_adj) + l3 * Math.cos(θ2_adj + θ3_adj + θ4_adj);
            positions.push({
                x: r3 * cosθ1,
                y: r3 * sinθ1,
                z: l0 + l1 * Math.sin(θ2_adj) + l2 * Math.sin(θ2_adj + θ3_adj) + l3 * Math.sin(θ2_adj + θ3_adj + θ4_adj)
            });
            
            // J5 position
            const r4 = l1 * Math.cos(θ2_adj) + l2 * Math.cos(θ2_adj + θ3_adj) + l3 * Math.cos(θ2_adj + θ3_adj + θ4_adj) + l4 * Math.cos(θ2_adj + θ3_adj + θ4_adj + θ5_adj);
            positions.push({
                x: r4 * cosθ1,
                y: r4 * sinθ1,
                z: l0 + l1 * Math.sin(θ2_adj) + l2 * Math.sin(θ2_adj + θ3_adj) + l3 * Math.sin(θ2_adj + θ3_adj + θ4_adj) + l4 * Math.sin(θ2_adj + θ3_adj + θ4_adj + θ5_adj)
            });
            
            // J6/End effector position (same as J5 for now, J6 only rotates)
            positions.push({
                x: r4 * cosθ1,
                y: r4 * sinθ1,
                z: l0 + l1 * Math.sin(θ2_adj) + l2 * Math.sin(θ2_adj + θ3_adj) + l3 * Math.sin(θ2_adj + θ3_adj + θ4_adj) + l4 * Math.sin(θ2_adj + θ3_adj + θ5_adj)
            });
            
            // Draw base pillar
            const baseWidth = 40;
            const baseDepth = 40;
            const baseHeight = l0;
            
            const pillarCorners = [
                { x: -baseWidth/2, y: -baseDepth/2, z: 0 },
                { x: baseWidth/2, y: -baseDepth/2, z: 0 },
                { x: baseWidth/2, y: baseDepth/2, z: 0 },
                { x: -baseWidth/2, y: baseDepth/2, z: 0 },
                { x: -baseWidth/2, y: -baseDepth/2, z: baseHeight },
                { x: baseWidth/2, y: -baseDepth/2, z: baseHeight },
                { x: baseWidth/2, y: baseDepth/2, z: baseHeight },
                { x: -baseWidth/2, y: baseDepth/2, z: baseHeight }
            ];
            
            const projectedCorners = pillarCorners.map(c => project3D(c.x, c.y, c.z));
            
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.moveTo(projectedCorners[0].x, projectedCorners[0].y);
            ctx.lineTo(projectedCorners[1].x, projectedCorners[1].y);
            ctx.lineTo(projectedCorners[2].x, projectedCorners[2].y);
            ctx.lineTo(projectedCorners[3].x, projectedCorners[3].y);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#A0826D';
            ctx.beginPath();
            ctx.moveTo(projectedCorners[4].x, projectedCorners[4].y);
            ctx.lineTo(projectedCorners[5].x, projectedCorners[5].y);
            ctx.lineTo(projectedCorners[6].x, projectedCorners[6].y);
            ctx.lineTo(projectedCorners[7].x, projectedCorners[7].y);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(projectedCorners[i].x, projectedCorners[i].y);
                ctx.lineTo(projectedCorners[i + 4].x, projectedCorners[i + 4].y);
                ctx.stroke();
            }
            
            drawLabel(0, 0, baseHeight, 'BASE', '#8B4513');
            
            // Draw base height label
            drawLinkLength(0, 0, 0, 0, 0, baseHeight, arm.lengths[0], '#8B4513');
            
            // Draw links with length labels
            for (let i = 1; i < positions.length - 1; i++) {
                drawLine3D(
                    positions[i].x, positions[i].y, positions[i].z,
                    positions[i + 1].x, positions[i + 1].y, positions[i + 1].z,
                    colors[i], 10
                );
                
                // Draw link length label
                drawLinkLength(
                    positions[i].x, positions[i].y, positions[i].z,
                    positions[i + 1].x, positions[i + 1].y, positions[i + 1].z,
                    arm.lengths[i], // L1, L2, L3, L4, L5
                    colors[i]
                );
            }
            
            // Draw joints
            const jointLabels = ['J1', 'J2', 'J3', 'J4', 'J5', 'J6'];
            for (let i = 1; i < positions.length; i++) {
                drawJoint(positions[i].x, positions[i].y, positions[i].z, 10, colors[i-1]);
                drawLabel(positions[i].x, positions[i].y, positions[i].z, jointLabels[i-1], colors[i-1]);
            }
            
            // Draw end effector
            const lastPos = positions[positions.length - 1];
            drawJoint(lastPos.x, lastPos.y, lastPos.z, 14, '#FF4757');
            drawLabel(lastPos.x, lastPos.y, lastPos.z, 'END', '#FF4757');
            
            // Draw end effector position on canvas
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'left';
            ctx.fillText(`X: ${arm.endEffector.x.toFixed(1)} mm`, 20, 30);
            ctx.fillText(`Y: ${arm.endEffector.y.toFixed(1)} mm`, 20, 50);
            ctx.fillText(`Z: ${arm.endEffector.z.toFixed(1)} mm`, 20, 70);
            
            const reach = Math.sqrt(
                arm.endEffector.x ** 2 + 
                arm.endEffector.y ** 2 + 
                arm.endEffector.z ** 2
            );
            ctx.fillText(`Reach: ${reach.toFixed(1)} mm`, 20, 90);
        }

        function drawGrid() {
            const gridSize = 100;
            const gridCount = 6;
            
            for (let i = -gridCount; i <= gridCount; i++) {
                const isMainGrid = i % 2 === 0;
                const lineWidth = isMainGrid ? 1.5 : 1;
                const alpha = isMainGrid ? 0.3 : 0.15;
                
                drawLine3D(
                    i * gridSize, -gridCount * gridSize, 0,
                    i * gridSize, gridCount * gridSize, 0,
                    `rgba(101, 67, 33, ${alpha})`, lineWidth
                );
                drawLine3D(
                    -gridCount * gridSize, i * gridSize, 0,
                    gridCount * gridSize, i * gridSize, 0,
                    `rgba(101, 67, 33, ${alpha})`, lineWidth
                );
            }
            
            drawLine3D(0, 0, 0, 150, 0, 0, '#FF0000', 4);
            drawLine3D(0, 0, 0, 0, 150, 0, '#00FF00', 4);
            drawLine3D(0, 0, 0, 0, 0, 150, '#0000FF', 4);
            
            if (showLabels) {
                const axisLabelOffset = 170;
                const xLabel = project3D(axisLabelOffset, 0, 0);
                const yLabel = project3D(0, axisLabelOffset, 0);
                const zLabel = project3D(0, 0, axisLabelOffset);
                
                ctx.font = 'bold 16px Arial';
                ctx.fillStyle = '#FF0000';
                ctx.fillText('X', xLabel.x, xLabel.y);
                ctx.fillStyle = '#00FF00';
                ctx.fillText('Y', yLabel.x, yLabel.y);
                ctx.fillStyle = '#0000FF';
                ctx.fillText('Z', zLabel.x, zLabel.y);
            }
        }

        function setView(view) {
            switch(view) {
                case 'top':
                    rotX = 5.5;
                    rotY = -0.5;
                    zoomLevel = 1.00;
                    break;
                case 'side':
                    rotX = -90.0;
                    rotY = -450.0;
                    zoomLevel = 2.00;
                    break;
                case 'iso':
                    rotX = -78.0;
                    rotY = -9.0;
                    zoomLevel = 1.00;
                    break;
            }
            document.getElementById('zoom-slider').value = zoomLevel;
            document.getElementById('zoom-val').textContent = Math.round(zoomLevel * 100) + '%';
            draw();
        }

        function updateZoom() {
            zoomLevel = parseFloat(document.getElementById('zoom-slider').value);
            document.getElementById('zoom-val').textContent = Math.round(zoomLevel * 100) + '%';
            draw();
        }

        function adjustZoom(delta) {
            zoomLevel = Math.max(0.5, Math.min(2.0, zoomLevel + delta));
            document.getElementById('zoom-slider').value = zoomLevel;
            document.getElementById('zoom-val').textContent = Math.round(zoomLevel * 100) + '%';
            draw();
        }

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                rotY += deltaX * 0.5;
                rotX += deltaY * 0.5;
                
                rotX = Math.max(-90, Math.min(90, rotX));
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                draw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            adjustZoom(delta);
        });

        initControls();
        forwardKinematics();
        updateDisplay();
        draw();
    </script>
</body>
</html>
